// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack
/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {
    static Array RAM;  // full RAM, not just heap
    static Array heap;
    static int freeList;  // linked list of available, (i.e., free) memory segments
    static int heapBase;
    static int heapBottom;
    static int RAMBottom;  // last addressable register (= KEYBOARD)

    /** Initializes the class. */
    function void init() {
        let heapBase = 2048;
        let heapBottom = 16383;   // register just before SCREEN, see p. 93
        let RAMBottom = 24576;  // see p. 93

        let freeList = heapBase;
        do Memory.poke(freeList, heapBottom - heapBase + 1);  // heap size = (16383 - 2048 + 1)
        do Memory.poke(freeList + 1, 0);  // address of next segment

        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        if ((address < 0) | (address > RAMBottom)) {
            do Output.printString("Error: invalid memory address!");
            do Sys.error(4);  // Invalid memory address
        }
        return RAM[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        if ((address < 0) | (address > RAMBottom)) {
            do Output.printString("Error: invalid memory address!");
            do Sys.error(4);  // Invalid memory address
        }
        let RAM[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
    function int alloc(int size) {
        var int block, segmentSize, nextSegment;
        var int current, previous;

        let current = freeList;
        let previous = 0;

        while (~(current = 0)) {
            let segmentSize = Memory.peek(current);
            let nextSegment = Memory.peek(current + 1);

            if (segmentSize > size + 2) {  // segment can be carved
                // Address of allocated block:
                let block = current + segmentSize - size;
                // Size of segment that was left:
                do Memory.poke(current, Memory.peek(current) - size - 1);
                do Memory.poke(block - 1, size + 1);  // size of allocated block, incl. size field;
                return block;
            } 
            if (segmentSize = size + 2) {  // segment can be carved, but only one register left over
                let block = current + 1;
                do Memory.poke(block - 1, size + 1);  // size of allocated block, incl. size field;
                // Incorporate left over register into previous segment:
                do Memory.poke(previous, Memory.peek(previous) + 1);
                do Memory.poke(previous + 1, nextSegment);  // adjust next pointer of prev. segment
                return block;
            }
            if (segmentSize = size + 1) {  // segment can be carved, nothing left over in original
                let block = current + 1;
                do Memory.poke(previous + 1, nextSegment);  // adjust next pointer of prev. segment
                return block;
            }
            let previous = current;
            let current = nextSegment;
        }
        // End of while, failed to allocate:
        do Output.printString("Cannot allocate, insufficient memory!");
        return -1;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */
    function void deAlloc(Array o) {
        // Make block address the new head of free list, and bind its next segment to original head:
        do Memory.poke(o, freeList);
        let freeList = o - 1;
        
        do Memory.defragment();
        return;
    }    

    /** Defragment the free list. */
    function void defragment() {
        var int current, currentSize, next, nextSize;

        let current = freeList;

        while (~(current = 0)) {
            let currentSize = Memory.peek(current);
            let next = Memory.peek(current + 1);
            
            if (next = 0) { return; }
            
            let nextSize = Memory.peek(next);
            if (next = current + currentSize) {
                // Merge current and next blocks if they are adjacent:
                do Memory.poke(current, currentSize + nextSize);
                do Memory.poke(current + 1, Memory.peek(next + 1));
            } else {
                let current = next;
            }
        }
        return;
    }
}